\chapter{资源感知调度系统实现}\label{chap:sched_policy}

\section{Control Zone任务调度}

% Control Zone内调度
% - 互斥调度：用于SMT或保守调度策略
% - 有资源阈值的互斥调度: 资源达到阈值时，才进行互斥调度(系统资源达到阈值时，使能BPF Scheduler)
%   - Memory、CPU、Network、IO

\subsection{强隔离任务调度策略}

多任务调度场景可分为两种。第一种是单CPU调度队列上的任务调度，此时任务分时复用CPU资源，调度策略通常采用优先级机制，并优先为高优先级任务分配CPU时间。第二种则是多CPU调度队列上的任务调度，Linux内核在这种场景下通常会允许任务在一定程度上的并发， 同时利用复杂均衡机制来避免任务过度集中。

混部场景中LC应用通常需要优先被保护，Linux中允许用户声明nice值来表达这一需求，但内核当前调度机制在设计上存在一些缺陷，使得nice值并不能完全的对高优先级应用进行保护。首先，在单CPU调度队列上，以Fair调度类为例，即便为LC应用指定了最高优先级，LC应用仍存在被抢占的可能，这是由于Fair调度类在实现上就以公平为目标，因此会极力比避免出现饥饿的情况出现，体现在实现中，随LC应用的vruntime的不断积累，其优先性慢慢削弱直至被抢占。其次，在多CPU调度队列上，优先级通常不能跨CPU地作用，此时任务调度主要受负载均衡影响，在第一章的分析中，Linux提出了调度域这一概念，其中就考虑到了不同CPU之间潜在的资源竞争情况，如在一个SMT系统中，即便运行在不同Sibling上的任务存在优先级差异，但此时并不能保证高优先级任务的资源使用。

针对以上存在的问题，本研究设计了一种强隔离的任务调度策略，并实现为BPF Scheduler，来提供一种能够对高优先任务进行强保护的调度策略。首先，对于单CPU队列上的隔离性问题，由于Sched Ext调度类本身优先级较低，结合第二章中对调度循环的分析可知，在每次调度循环中， 较高优先级调度类中的任务总是会被优先选中，而同时只有在高优先级调度类中没有可执行的任务时，才会进入Sched Ext调度类的流程中，因此使用Sched Ext调度类天然就实现了单CPU调度队列上的隔离性。

多CPU调度队列上的强隔离实现则较为复杂。首先，在BPF Scheduler中，选择使用一个全局DSQ，并通过cpu\_acquire，cpu\_release两个回调函数来动态获取当前Sched Ext中所能使用的CPU数量，而具体的调度逻辑如伪代码所示，

\subsection{资源约束的任务调度策略}

% Control Zone级调度
% - 更具优先级的资源划分

\section{Control Zone资源划分}